This library supports some version identifiers, some of which are essential to know about when compiling/linking.

Some are set or not set automatically by the compiler for the environment used (as documented by DMD), like GNU, Posix, Windows, LittleEndian



ENABLE_ACOS5_64_UI
Set version=ENABLE_ACOS5_64_UI, if You want to enable being notified and asked each time for consent, when a private RSA key shall be used for Signing data (this is not necessary for Decryption, I beleive).
The settings for that are done in opensc.conf. No entry for user_consent_enabled defaults to true, which then requires an entry for the application to launch (typically pinentry-qt, which has the alias pinentry for me).
This way, a window will pop up before signing is done or canceled, whatever You decide. The opensc.conf entry for that is this:

	card_driver acos5_64 {
		# The name and location of the driver library
		# if it's not in a 'OS's standard search path' for libs: module = /path/to/libacos5_64.so;
		module = libacos5_64.so;
		# Parameters for the PinEntry UserInterface; defaults: app[pinentry], enabled[true]
		user_consent_app = /usr/bin/pinentry;
		user_consent_enabled = true;
	}


FAKE_SUCCESS_FOR_SIGN_VERIFY_TESTS
TRY_SUCCESS_FOR_SIGN_VERIFY_TESTS
These 2 version identifiers are to be used only for pkcs11-tool --test ! DON'T USE THEM FOR REGULAR USE CASES !
IMHO some of these tests are sending data to be signed which don't comply with PKCS#1. thus would be refused by acos5_64_compute_signature in it's regular operation.
Using one or both version identifiers weakens the requirements and may result in less errors indicated by pkcs11-tool.
Set version=FAKE_SUCCESS_FOR_SIGN_VERIFY_TESTS to FAKE a signing success for 1 test case, where no 01_padding is contained in the data. Effectively no signing takes place, the test-procedure gos on and indicates an expected verification error. From a security perspective, using this version identifier is still save.
Set version=TRY_SUCCESS_FOR_SIGN_VERIFY_TESTS to get tests passed, that supply data with correct padding, but data's payload are zeros only of length len <= max k-11 (no digestInfo given).
From a security perspective, I consider using this version identifier as UNSAFE, because an attacker might get some information about the key used.


USE_SODIUM, RSA_PKCS_PSS, RESTRICTED_SN_TOKEN, SEALED_BINARY  will come later:

USE_SODIUM
currently the code makes no use of sodium. This will come later.
Set version=USE_SODIUM, if You want to take advantage from libsodium's capabilities: Regarding memory protection of sensible private data, it allows a higher level, like disalow swapping these data, disalow core dumps to contain these data (same for kernel crash dumps),
makeing these data inaccessible while not actually in use and auto-zeroing sensible data memory when usage has finished etc. It's cryptographic capabilities aren't used currently, as there is the mandatory openssl too.

RSA_PKCS_PSS
currently not publicly usable.
There is an experimental way to sign ala RSASSA-PSS. opensc currently doesn't support PSS, and You can make use of it only in some tricky way for keys that allow both signing AND decipher (additional requirement of an unpublished package pkcs11).

RESTRICTED_SN_TOKEN
This is meant to be used later in cases, where the driver has to be functional only if a specific token (i.e. token's serial no.) is present, otherwise, the driver refuses to init() and gets unloaded.
The serial no. has to be inserted into the source code and set version=RESTRICTED_SN_TOKEN.

SEALED_BINARY
not yet implemented publicly
An idea: once a binary is produced, check a value identifying the binary, whether it has been forged;


REINITIALIZE
not yet implemented publicly
will vanish, once it's code is integrated;

none/all

### IMPORTANT: ###

The following is a copy of version identifiers from package libopensc ! They are essential for this package too.
================================================================================================================
This library supports some version identifiers, some of which are essential to know about when compiling/linking against a binary libopensc.so/dll.
Except SIMCLIST_WITH_THREADS and ENABLE_SM which stem from opensc, they are introduced by this binding:

Let's assume a project called "carddriver", that depends on this package.

There are then - whith regard to DUB - 2 dub.json files to be considered for specification of version identifiers.
In either case the carddriver's dub.json is a suitable choice, as DUB "passes" version identifiers to it's dependencies, overriding possibly conflicting settings.

But some version identifiers can be thougth of as rarely changing, making opensc's dub.json fit equally or better.
I consider this to be true for the next (libopensc related version identifiers), thus taken care for in this package's dub.json according to defaults of a Linux build of opensc.


Specifying the libopensc's binary version to link against and related settings:
===============================================================================

version=

FAKE_OPENSC_VERSION  [default: not set]
Set version=FAKE_OPENSC_VERSION, if linking against opensc's version 0.15.0, otherwise don't, which implies linking against opensc's version 0.16.0.
This controls differences in th APIs that have to be taken care of (e.g. some structs have other fields and differing .sizeof, module auxdata available or not, new functions available or not etc.).
This also controls, which functions are actually callable from the binary (independent from API differences, as 0.15.0 didn't export some existing functions, though part of the API,
which involved having to duplicate some code for acos5_64 specially for 0.15.0. In the meantime version 0.16.0 appeared, being more generous about exports).
From the bottom of my heart I dislike code duplication, bloat and stopped that, switched to patch opensc where the decicision is taken about export of those functions.


PATCH_LIBOPENSC_EXPORTS  [default: not set]
For opensc's version 0.15.0, the declarations in scopes version(PATCH_LIBOPENSC_EXPORTS) are NOT available, thus You are reminded by compiler errors rather than linker errors.
Set version=PATCH_LIBOPENSC_EXPORTS to get the declarations and You'll know what needs patching, if it's required to be called from the binary.
It's also helpfull, to compile the "carddriver"  with "lflags" : ["--no-undefined", "possibly other flags"]


SIMCLIST_WITH_THREADS  [default: not set]
by default, opensc get's build without  SIMCLIST_WITH_THREADS  being defined, and in this case there is no need to care about this version identifier (just don't use it).
Otherwise, being defined for the opensc build, version=SIMCLIST_WITH_THREADS   ***MUST***  be used in order to match list_t.sizeof and all .sizeof of types that depend on list_t !


ENABLE_SM  [default: set]
Same as with all version identifiers in this libopensc related section, this has to match how libopensc was build. The default is with SM enabled !
Depending what is used by "carddriver", it may be required to link to libsmm-local.so/.dll as well.


Any mismatch in this section will sooner or later inevitably cause a SIGSEGV.


Other version identifiers, intended for development/debugging only 
==================================================================

ENABLE_TOSTRING  [default: not set]
This is for debugging/watching what is going on related to values, an alternative to scattered 'sc_do_log(s)'. A developper will appreciate the deep insight and know how to make use of it.
Without version=ENABLE_TOSTRING, this binding doesn't need compilation and dub.json is configured accordingly. Otherwise, dub.json needs to be changed as well.

ENABLE_TOSTRING_SM_GP   [default: not set]
ENABLE_TOSTRING_SM_CWA  [default: not set]
ENABLE_TOSTRING_SM_DH   [default: not set]
There is a union holding either GP or CWA or DH data. Only with version=ENABLE_SM and version=ENABLE_TOSTRING, and only one of these set, it controls, which part of the union to be considered in function toString.
